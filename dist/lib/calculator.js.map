{"version":3,"sources":["../../src/lib/calculator.js"],"names":["funcs","Calculator","sheet","parser","_makeParser","tabs","tabsById","valueSeq","deps","providesTo","vals","map","t","get","calculateAll","_processCalculations","_allCellRefs","valuesByCellRef","forEach","value","cellRef","cell","getCell","_setCellValue","toEval","keySeq","skipWhile","has","r","toList","formula","defaultTabId","withDefaultTabId","formulaValue","parse","error","result","rangeRef","mapRange","_getCellValue","bind","getFormattedCell","val","format","order","_calculateCellValue","allCellRefs","toSet","evaluateFormula","staticValue","remoteValue","tabId","rowIdx","colIdx","set","getIn","setIn","tab","on","done","row","column","of","getTab","index","startCellCoord","endCellCoord","explicitTabId","range","getRange","Object","keys","setFunction","name","fn"],"mappings":"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","file":"calculator.js","sourcesContent":["import { Map, List } from 'immutable';\nimport { Parser } from 'hot-formula-parser';\nimport { CellRef, CellRefRange } from 'sheety-model';\nimport evalOrder from './eval-order';\nimport partialEvalOrder from './partial-eval-order';\nimport deps from './deps';\nimport depsToProvides from './deps-to-provides';\nimport * as funcs from './sheet-funcs';\n\nexport default class Calculator {\n  constructor(sheet) {\n    this.sheet = sheet;\n    this.parser = this._makeParser();\n\n    const tabs = sheet.tabsById.valueSeq();\n    // Map from dependent to dependency cells\n    this.deps = deps(tabs);\n    // Map from CellRef p to List of CellRefs r where p provides a value needed by each r.\n    this.providesTo = depsToProvides(this.deps);\n    // Map from tab id to a List of Lists (rows and cells in the row)\n    this.vals = new Map(tabs.map(t => [t.get('id'), new List()]));\n\n    this.calculateAll();\n  }\n\n  /**\n   * Calculate the full sheet without any user input.\n   *\n   * Returns a map from tab ids to a List of Lists of values.\n   **/\n  calculateAll() {\n    return this._processCalculations(evalOrder(this.deps, this._allCellRefs()));\n  }\n\n  setValues(valuesByCellRef) {\n    valuesByCellRef.forEach((value, cellRef) => {\n      const cell = this.sheet.getCell(cellRef);\n      if ( !cell.get('isUserEditable') ) {\n        // TODO\n      }\n\n      this._setCellValue(cellRef, value);\n    });\n\n    const toEval = partialEvalOrder(\n      this.providesTo,\n      valuesByCellRef.keySeq()\n    ).skipWhile(r => valuesByCellRef.has(r)).toList()\n\n    return this._processCalculations(toEval);\n  }\n\n  /**\n   * Evaluate the formula provided, using defaultTabId as the tab for any\n   * cell references without a tab.\n   **/\n  evaluateFormula(formula, defaultTabId) {\n    return withDefaultTabId(defaultTabId, this.parser, () => {\n      const formulaValue = this.parser.parse(formula);\n      if ( formulaValue.error ) {\n        // TODO\n        return formulaValue.error;\n      }\n\n      return formulaValue.result;\n    });\n  }\n\n  /** Given an A1 range, rangeRef, return the values of the corresponding cells\n   *  in an NxM matrix (2-d array).\n   **/\n  getRange(rangeRef) {\n    return this.sheet.mapRange(\n      rangeRef,\n      this._getCellValue.bind(this)\n    );\n  }\n\n  /**\n   * Given an A1 range, rangeRef, return the formatted values of the corresponding cells\n   * in an NxM matrix (2-d array).\n   **/\n  getFormattedRange(rangeRef) {\n    return this.sheet.mapRange(\n      rangeRef,\n      this.getFormattedCell.bind(this)\n    );\n  }\n\n  /**\n   * Given an A1 reference, return the formatted value of the corresponding cell.\n   **/\n  getFormattedCell(cellRef) {\n    const val = this._getCellValue(cellRef);\n    const cell = this.sheet.getCell(cellRef);\n    const format = cell.get('format');\n\n    return format.format(val);\n  }\n\n  /**\n   * Evaluate each cell in order.\n   **/\n  _processCalculations(order) {\n    order.forEach((cellRef) => {\n      this._setCellValue(cellRef, this._calculateCellValue(cellRef));\n    });\n\n    return this.vals;\n  }\n\n  /**\n   * Return all cell references for all tabs.\n   **/\n  _allCellRefs() {\n    return this.sheet.allCellRefs().toSet();\n  }\n\n  /**\n   * Calculates the value of the cell at the given ref.\n   **/\n  _calculateCellValue(cellRef) {\n    const cell = this.sheet.getCell(cellRef);\n\n    const formula = cell.get('formula');\n    if ( formula ) {\n      return this.evaluateFormula(formula, cellRef.get('tabId'));\n    }\n\n    const staticValue = cell.get('staticValue');\n    if ( staticValue !== null ) {\n      return staticValue;\n    }\n\n    const remoteValue = cell.get('remoteValue');\n    if ( remoteValue ) {\n      // TODO: handle remote values\n    }\n\n    return this._getCellValue(cellRef);\n  }\n\n  /**\n   * Sets the value of the cell at the given ref, regardless of user-editability.\n   **/\n  _setCellValue(cellRef, value) {\n    const tabId = cellRef.get('tabId');\n    const rowIdx = cellRef.get('rowIdx');\n    const colIdx = cellRef.get('colIdx');\n\n    if ( !this.vals.has(tabId) ) {\n      this.vals = this.vals.set(tabId, new List());\n    }\n    if ( !this.vals.getIn([tabId, rowIdx]) ) {\n      this.vals = this.vals.setIn([tabId, rowIdx], new List());\n    }\n    this.vals = this.vals.setIn([cellRef.get('tabId'), cellRef.get('rowIdx'), cellRef.get('colIdx')], value);\n  }\n\n  /**\n   * Returns the previously-set value of the cell at the given ref.\n   **/\n  _getCellValue(cellRef) {\n    const tab = this.vals.get(cellRef.get('tabId'))\n    if ( !tab ) {\n      return null;\n    }\n\n    return tab.getIn([cellRef.get('rowIdx'), cellRef.get('colIdx')]);\n  }\n\n  _makeParser() {\n    const parser = new Parser();\n\n    parser.on('callCellValue', ({row, column, tab}, done) => {\n      const tabId = tab || parser.defaultTabId;\n      const cellRef = CellRef.of(this.sheet.getTab(tabId), row.index, column.index);\n      done(this._getCellValue(cellRef));\n    });\n\n    parser.on('callRangeValue', (startCellCoord, endCellCoord, explicitTabId, done) => {\n      const tabId = explicitTabId || parser.defaultTabId;\n      const tab = this.sheet.getTab(tabId);\n      const rangeRef = CellRefRange.of(\n        tab,\n        startCellCoord.row.index,\n        startCellCoord.column.index,\n        endCellCoord.row.index,\n        endCellCoord.column.index\n      );\n      const range = this.getRange(rangeRef);\n      done(range);\n    });\n\n    Object.keys(funcs).forEach(name => {\n      parser.setFunction(name, funcs[name]);\n    });\n\n    return parser;\n  }\n}\n\nfunction withDefaultTabId(defaultTabId, parser, fn) {\n  parser.defaultTabId = defaultTabId;\n  const result = fn();\n  parser.defaultTabId = null;\n  return result;\n}\n"]}