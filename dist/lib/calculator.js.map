{"version":3,"sources":["../../src/lib/calculator.js"],"names":["funcs","LOADING","Calculator","sheet","extraFormulaFuncs","userUpdateFuncs","parser","_makeParser","tabs","get","valueSeq","theDeps","providesTo","vals","map","t","cellValueCache","userValueCache","globalOrder","_allCellRefs","calculateAll","_processCalculations","valuesByCellRef","forEach","value","cellRef","cell","getCell","_setCellValue","_hasUserValueFunc","set","evaluateFormula","_evalDependents","keySeq","formula","upperCaseFormula","toUpperCase","Object","keys","some","startsWith","f","of","cellRefs","toEval","skipWhile","includes","r","toList","assocData","withAssociatedParserData","formulaValue","parse","error","result","rangeRef","mapRange","_getCellValue","bind","getFormattedCell","val","format","order","_calculateCellValue","allCellRefs","toSet","skipCache","cachedValue","remove","staticValue","remoteValue","tabId","rowIdx","colIdx","has","getIn","setIn","tab","on","done","row","column","defaultTabId","getTab","index","startCellCoord","endCellCoord","explicitTabId","range","getRange","setFunction","name","func","wrapped","params","userValueHandler","userValue","consumed","associatedData","fn","k"],"mappings":"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","file":"calculator.js","sourcesContent":["import { Set, Map, List } from 'immutable';\nimport { Parser } from 'hot-formula-parser';\nimport { Sheet, CellRef, CellRefRange } from 'sheety-model';\nimport evalOrder from './eval-order';\nimport partialEvalOrder from './partial-eval-order';\nimport deps from './deps';\nimport depsToProvides from './deps-to-provides';\nimport * as funcs from './sheet-funcs';\n\n// Used as a sentinel to indicate in-progress async calcs\nconst LOADING = {};\n\nexport default class Calculator {\n  /**\n   * extraFormulaFuncs is a mapping from function names to functions\n   * that will be accessible from formulas.  The functions take a params\n   * array and a cell reference.\n   *\n   * userUpdateFuncs is a mapping from function names to functions\n   * that will be invoked whenever a value is set for a cell with a formula\n   * utilizing the corresponding function.\n   **/\n  constructor(sheet, extraFormulaFuncs = {}, userUpdateFuncs = {}) {\n    this.sheet = new Sheet(sheet);\n    this.parser = this._makeParser(extraFormulaFuncs);\n    this.userUpdateFuncs = userUpdateFuncs;\n\n    const tabs = this.sheet.get('tabsById').valueSeq();\n    // Map from dependent to dependency cells\n    const theDeps = deps(tabs);\n    // Map from CellRef p to List of CellRefs r where p provides a value needed by each r.\n    this.providesTo = depsToProvides(theDeps);\n    // Map from tab id to a List of Lists (rows and cells in the row)\n    this.vals = new Map(tabs.map(t => [t.get('id'), new List()]));\n    // Map from CellRef c to the pre-calculated value of a formula.  Primarily useful for async funcs.\n    this.cellValueCache = new Map();\n    // Map from CellRef c to the user-supplied value if c contains a formula making use of a userUpdateFunc.\n    this.userValueCache = new Map();\n    this.globalOrder = evalOrder(theDeps, this._allCellRefs());\n\n    this.calculateAll(this.globalOrder);\n  }\n\n  /**\n   * Calculate the full sheet without any user input.\n   *\n   * Returns a map from tab ids to a List of Lists of values.\n   **/\n  calculateAll(globalOrder) {\n    return this._processCalculations(globalOrder);\n  }\n\n  /**\n   * Sets the values of provided cells.\n   **/\n  setValues(valuesByCellRef) {\n    valuesByCellRef.forEach((value, cellRef) => {\n      const cell = this.sheet.getCell(cellRef);\n      if ( !cell.get('isUserEditable') ) {\n        // TODO: should we throw here?  refuse to update?\n      }\n\n      this._setCellValue(cellRef, value);\n\n      // here, we handle user value functions in formulas\n      if ( this._hasUserValueFunc(cell) ) {\n        this.userValueCache = this.userValueCache.set(cellRef, value);\n        this.evaluateFormula(cell.get('formula'), cellRef);\n      }\n    });\n\n    return this._evalDependents(new Set(valuesByCellRef.keySeq()));\n  }\n\n  _hasUserValueFunc(cell) {\n    const formula = cell.get('formula');\n    if ( !formula ) {\n      return false;\n    }\n\n    const upperCaseFormula = formula.toUpperCase();\n\n    return Object.keys(this.userUpdateFuncs)\n                 .some(f => upperCaseFormula.startsWith(f.toUpperCase() + '('));\n  }\n\n  /**\n   * This is primarily useful for asynchronous sheet functions.\n   * After calculating their value, async functions can set a cached\n   * cell value.\n   **/\n  setCachedCellValue(cellRef, value) {\n    this.cellValueCache = this.cellValueCache.set(cellRef, value);\n    this._setCellValue(cellRef, value);\n    return this._evalDependents(Set.of(cellRef));\n  }\n\n  _evalDependents(cellRefs) {\n    const toEval = partialEvalOrder(\n      this.providesTo,\n      this.globalOrder,\n      cellRefs\n    ).skipWhile(r => cellRefs.includes(r)).toList()\n\n    return this._processCalculations(toEval);\n  }\n\n  /**\n   * Evaluate the formula provided, using cellRef to resolve ambiguous\n   * references (those without a tab specified) and to resolve async functions.\n   **/\n  evaluateFormula(formula, cellRef) {\n    const assocData = { cellRef };\n    return withAssociatedParserData(assocData, this.parser, () => {\n      const formulaValue = this.parser.parse(formula);\n      if ( formulaValue.error ) {\n        // TODO\n        return formulaValue.error;\n      }\n\n      return formulaValue.result;\n    });\n  }\n\n  /** Given an A1 range, rangeRef, return the values of the corresponding cells\n   *  in an NxM matrix (2-d array).\n   **/\n  getRange(rangeRef) {\n    return this.sheet.mapRange(\n      rangeRef,\n      this._getCellValue.bind(this)\n    );\n  }\n\n  /**\n   * Given an A1 range, rangeRef, return the formatted values of the corresponding cells\n   * in an NxM matrix (2-d array).\n   **/\n  getFormattedRange(rangeRef) {\n    return this.sheet.mapRange(\n      rangeRef,\n      this.getFormattedCell.bind(this)\n    );\n  }\n\n  /**\n   * Given an A1 reference, return the formatted value of the corresponding cell.\n   **/\n  getFormattedCell(cellRef) {\n    const val = this._getCellValue(cellRef);\n    const cell = this.sheet.getCell(cellRef);\n    const format = cell && cell.get('format');\n\n    return format ? format.format(val) : val;\n  }\n\n  /**\n   * Evaluate each cell in order.\n   **/\n  _processCalculations(order) {\n    order.forEach((cellRef) => {\n      this._setCellValue(cellRef, this._calculateCellValue(cellRef, true));\n    });\n\n    return this.vals;\n  }\n\n  /**\n   * Return all cell references for all tabs.\n   **/\n  _allCellRefs() {\n    return this.sheet.allCellRefs().toSet();\n  }\n\n  /**\n   * Calculates the value of the cell at the given ref.\n   * If skipCache is not set, we will prefer pre-calculated values for any\n   * formulas that provided them.\n   * If skipCache is set, we will always re-calculate formulas.\n   **/\n  _calculateCellValue(cellRef, skipCache) {\n    const cell = this.sheet.getCell(cellRef);\n\n    const formula = cell.get('formula');\n    if ( formula ) {\n      const cachedValue = this.cellValueCache.get(cellRef);\n      if ( !skipCache && !!cachedValue ) {\n        return cachedValue;\n      }\n\n      this.cellValueCache = this.cellValueCache.remove(cellRef);\n      return this.evaluateFormula(formula, cellRef);\n    }\n\n    const staticValue = cell.get('staticValue');\n    if ( staticValue !== null ) {\n      return staticValue;\n    }\n\n    const remoteValue = cell.get('remoteValue');\n    if ( remoteValue ) {\n      // TODO: handle remote values\n    }\n\n    return this._getCellValue(cellRef);\n  }\n\n  /**\n   * Sets the value of the cell at the given ref, regardless of user-editability.\n   **/\n  _setCellValue(cellRef, value) {\n    const tabId = cellRef.get('tabId');\n    const rowIdx = cellRef.get('rowIdx');\n    const colIdx = cellRef.get('colIdx');\n\n    if ( !this.vals.has(tabId) ) {\n      this.vals = this.vals.set(tabId, new List());\n    }\n    if ( !this.vals.getIn([tabId, rowIdx]) ) {\n      this.vals = this.vals.setIn([tabId, rowIdx], new List());\n    }\n    this.vals = this.vals.setIn([cellRef.get('tabId'), cellRef.get('rowIdx'), cellRef.get('colIdx')], value);\n  }\n\n  /**\n   * Returns the previously-set value of the cell at the given ref.\n   **/\n  _getCellValue(cellRef) {\n    const tab = this.vals.get(cellRef.get('tabId'))\n    if ( !tab ) {\n      return null;\n    }\n\n    return tab.getIn([cellRef.get('rowIdx'), cellRef.get('colIdx')]);\n  }\n\n  _makeParser(extraFormulaFuncs) {\n    const parser = new Parser();\n\n    parser.on('callCellValue', ({row, column, tab}, done) => {\n      const defaultTabId = parser.cellRef && parser.cellRef.get('tabId');\n      const tabId = tab || defaultTabId;\n      const cellRef = CellRef.of(this.sheet.getTab(tabId), row.index, column.index);\n      done(this._getCellValue(cellRef));\n    });\n\n    parser.on('callRangeValue', (startCellCoord, endCellCoord, explicitTabId, done) => {\n      const defaultTabId = parser.cellRef && parser.cellRef.get('tabId');\n      const tabId = explicitTabId || defaultTabId;\n      const tab = this.sheet.getTab(tabId);\n      const rangeRef = CellRefRange.of(\n        tab,\n        startCellCoord.row.index,\n        startCellCoord.column.index,\n        endCellCoord.row.index,\n        endCellCoord.column.index\n      );\n      const range = this.getRange(rangeRef);\n      done(range);\n    });\n\n    Object.keys(funcs).forEach(name => {\n      parser.setFunction(name, funcs[name]);\n    });\n\n    Object.keys(extraFormulaFuncs).forEach(name => {\n      const func = extraFormulaFuncs[name];\n      const wrapped = (params) => {\n        const cellRef = parser.cellRef;\n        const userValueHandler = this.userUpdateFuncs[name];\n        if ( this.userValueCache.has(cellRef) && userValueHandler ) {\n          const userValue = this.userValueCache.get(cellRef);\n          const consumed = userValueHandler(params, cellRef, userValue);\n          if ( consumed ) {\n            this.userValueCache = this.userValueCache.remove(cellRef);\n          }\n\n          return userValue;\n        }\n\n        return func(params, cellRef)\n      };\n      parser.setFunction(name.toUpperCase(), wrapped);\n    });\n\n    return parser;\n  }\n}\n\nCalculator.LOADING = LOADING;\n\nfunction withAssociatedParserData(associatedData, parser, fn) {\n  Object.keys(associatedData).forEach(k => {\n    parser[k] = associatedData[k];\n  });\n  const result = fn();\n  Object.keys(associatedData).forEach(k => {\n    parser[k] = null;\n  });\n  return result;\n}\n"]}