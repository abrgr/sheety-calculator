{"version":3,"sources":["../../src/lib/deps.js"],"names":["deps","tabs","parser","getDependencyParser","reduce","tab","get","row","rowIdx","cell","colIdx","set","of","parse","dependentCells","on","cellCoord","done","push","tabId","index","column","startCellCoord","endCellCoord","rangeTab","range","start","end","dependentRows","mapCellRefs","cellRef","cells","concat","origParse","_tab","expr","call","depCells"],"mappings":";;;;;kBASwBA,I;;AATxB;;AACA;;AACA;;AAEA;;;;;AAKe,SAASA,IAAT,CAAcC,IAAd,EAAoB;AACjC,MAAMC,SAASC,qBAAf;;AAEA,SAAOF,KAAKG,MAAL,CAAY,UAACJ,IAAD,EAAOK,GAAP;AAAA,WACjBA,IAAIC,GAAJ,CAAQ,MAAR,EAAgBF,MAAhB,CAAuB,UAACJ,IAAD,EAAOO,GAAP,EAAYC,MAAZ;AAAA,aACrBD,IAAIH,MAAJ,CAAW,UAACJ,IAAD,EAAOS,IAAP,EAAaC,MAAb;AAAA,eACTD,KAAKH,GAAL,CAAS,SAAT,IACIN,KAAKW,GAAL,CAAS,qBAAQC,EAAR,CAAWP,GAAX,EAAgBG,MAAhB,EAAwBE,MAAxB,CAAT,EAA0CR,OAAOW,KAAP,CAAaR,IAAIC,GAAJ,CAAQ,IAAR,CAAb,EAA4BG,KAAKH,GAAL,CAAS,SAAT,CAA5B,CAA1C,CADJ,GAEIN,IAHK;AAAA,OAAX,EAIGA,IAJH,CADqB;AAAA,KAAvB,EAMGA,IANH,CADiB;AAAA,GAAZ,EAQJ,oBARI,CAAP;AASD;;AAED,SAASG,mBAAT,GAA+B;AAC7B,MAAMD,SAAS,8BAAf;AACA,MAAIY,iBAAiB,qBAArB;AACA,MAAIT,MAAM,IAAV;AACAH,SAAOa,EAAP,CAAU,eAAV,EAA2B,UAACC,SAAD,EAAYC,IAAZ,EAAqB;AAC9CH,qBAAiBA,eAAeI,IAAf,CACf,yBAAY;AACVC,aAAOH,UAAUX,GAAV,IAAiBA,GADd;AAEVG,cAAQQ,UAAUT,GAAV,CAAca,KAFZ;AAGVV,cAAQM,UAAUK,MAAV,CAAiBD;AAHf,KAAZ,CADe,CAAjB;AAOAH,SAAK,CAAL,EAR8C,CAQrC;AACV,GATD;AAUAf,SAAOa,EAAP,CAAU,gBAAV,EAA4B,UAACO,cAAD,EAAiBC,YAAjB,EAA+BC,QAA/B,EAAyCP,IAAzC,EAAkD;AAC5E,QAAMQ,QAAQ,8BAAiB;AAC7BC,aAAO;AACLP,eAAOK,YAAYnB,GADd;AAELG,gBAAQc,eAAef,GAAf,CAAmBa,KAFtB;AAGLV,gBAAQY,eAAeD,MAAf,CAAsBD;AAHzB,OADsB;AAM7BO,WAAK;AACHR,eAAOK,YAAYnB,GADhB;AAEHG,gBAAQe,aAAahB,GAAb,CAAiBa,KAFtB;AAGHV,gBAAQa,aAAaF,MAAb,CAAoBD;AAHzB;AANwB,KAAjB,CAAd;AAYA,QAAMQ,gBAAgBH,MAAMI,WAAN,CAAkB;AAAA,aACtCC,QAAQnB,GAAR,CAAY,OAAZ,EAAqBmB,QAAQxB,GAAR,CAAY,OAAZ,KAAwBD,GAA7C,CADsC;AAAA,KAAlB,CAAtB;;AAIAS,qBAAiBc,cAAcxB,MAAd,CAAqB,UAAC2B,KAAD,EAAQxB,GAAR,EAAgB;AACpD,aAAOwB,MAAMC,MAAN,CAAa,oBAASzB,GAAT,CAAb,CAAP;AACD,KAFgB,EAEdO,cAFc,CAAjB;;AAIA,WAAO,CAAC,EAAD,CAAP;AACD,GAtBD;;AAwBA,MAAMmB,YAAY/B,OAAOW,KAAzB;AACAX,SAAOW,KAAP,GAAe,UAASqB,IAAT,EAAeC,IAAf,EAAqB;AAClC9B,UAAM6B,IAAN;AACApB,qBAAiB,qBAAjB;;AAEAmB,cAAUG,IAAV,CAAe,IAAf,EAAqBD,IAArB;;AAEA,QAAME,WAAWvB,cAAjB;AACAA,qBAAiB,qBAAjB;AACA,WAAOuB,QAAP;AACD,GATD;;AAWA,SAAOnC,MAAP;AACD","file":"deps.js","sourcesContent":["import { List, Map } from 'immutable';\nimport { Parser } from 'hot-formula-parser';\nimport { CellRef, CellRefRange } from 'sheety-model';\n\n/**\n * deps takes a collection of SheetyModel Tab objects and returns\n * a Map from CellRef c to a collection of CellRefs d, where each\n * CellRef c depends on the result of the CellRefs d.\n **/\nexport default function deps(tabs) {\n  const parser = getDependencyParser();\n\n  return tabs.reduce((deps, tab) => (\n    tab.get('rows').reduce((deps, row, rowIdx) => (\n      row.reduce((deps, cell, colIdx) => (\n        cell.get('formula')\n          ? deps.set(CellRef.of(tab, rowIdx, colIdx), parser.parse(tab.get('id'), cell.get('formula')))\n          : deps\n      ), deps)\n    ), deps)\n  ), new Map());\n}\n\nfunction getDependencyParser() {\n  const parser = new Parser();\n  let dependentCells = new List();\n  let tab = null;\n  parser.on('callCellValue', (cellCoord, done) => {\n    dependentCells = dependentCells.push(\n      new CellRef({\n        tabId: cellCoord.tab || tab,\n        rowIdx: cellCoord.row.index,\n        colIdx: cellCoord.column.index\n      })\n    );\n    done(0); // we don't care about the value\n  });\n  parser.on('callRangeValue', (startCellCoord, endCellCoord, rangeTab, done) => {\n    const range = new CellRefRange({\n      start: {\n        tabId: rangeTab || tab,\n        rowIdx: startCellCoord.row.index,\n        colIdx: startCellCoord.column.index\n      },\n      end: {\n        tabId: rangeTab || tab,\n        rowIdx: endCellCoord.row.index,\n        colIdx: endCellCoord.column.index\n      }\n    });\n    const dependentRows = range.mapCellRefs(cellRef => (\n      cellRef.set('tabId', cellRef.get('tabId') || tab)\n    ));\n\n    dependentCells = dependentRows.reduce((cells, row) => {\n      return cells.concat(new List(row))\n    }, dependentCells);\n\n    return [[]];\n  });\n\n  const origParse = parser.parse;\n  parser.parse = function(_tab, expr) {\n    tab = _tab;\n    dependentCells = new List();\n\n    origParse.call(this, expr);\n\n    const depCells = dependentCells;\n    dependentCells = new List();\n    return depCells;\n  };\n\n  return parser;\n}\n"]}