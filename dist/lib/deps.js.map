{"version":3,"sources":["../../src/lib/deps.js"],"names":["deps","tabs","parser","getDependencyParser","reduce","tab","get","row","rowIdx","cell","colIdx","set","of","parse","dependentCells","on","cellCoord","done","push","index","column","startCellCoord","endCellCoord","origParse","_tab","expr","call","depCells"],"mappings":";;;;;kBASwBA,I;;AATxB;;AACA;;AACA;;AAEA;;;;;AAKe,SAASA,IAAT,CAAcC,IAAd,EAAoB;AACjC,MAAMC,SAASC,qBAAf;;AAEA,SAAOF,KAAKG,MAAL,CAAY,UAACJ,IAAD,EAAOK,GAAP;AAAA,WACjBA,IAAIC,GAAJ,CAAQ,MAAR,EAAgBF,MAAhB,CAAuB,UAACJ,IAAD,EAAOO,GAAP,EAAYC,MAAZ;AAAA,aACrBD,IAAIH,MAAJ,CAAW,UAACJ,IAAD,EAAOS,IAAP,EAAaC,MAAb;AAAA,eACTD,KAAKH,GAAL,CAAS,SAAT,IACIN,KAAKW,GAAL,CAAS,qBAAQC,EAAR,CAAWP,GAAX,EAAgBG,MAAhB,EAAwBE,MAAxB,CAAT,EAA0CR,OAAOW,KAAP,CAAaR,GAAb,EAAkBI,KAAKH,GAAL,CAAS,SAAT,CAAlB,CAA1C,CADJ,GAEIN,IAHK;AAAA,OAAX,EAIGA,IAJH,CADqB;AAAA,KAAvB,EAMGA,IANH,CADiB;AAAA,GAAZ,EAQJ,oBARI,CAAP;AASD;;AAED,SAASG,mBAAT,GAA+B;AAC7B,MAAMD,SAAS,8BAAf;AACA,MAAIY,iBAAiB,qBAArB;AACA,MAAIT,MAAM,IAAV;AACAH,SAAOa,EAAP,CAAU,eAAV,EAA2B,UAACC,SAAD,EAAYC,IAAZ,EAAqB;AAC9CH,qBAAiBA,eAAeI,IAAf,CACf,qBAAQN,EAAR,CAAWP,GAAX,EAAgBW,UAAUT,GAAV,CAAcY,KAA9B,EAAqCH,UAAUI,MAAV,CAAiBD,KAAtD,CADe,CAAjB;AAGAF,SAAK,CAAL,EAJ8C,CAIrC;AACV,GALD;AAMAf,SAAOa,EAAP,CAAU,gBAAV,EAA4B,UAACM,cAAD,EAAiBC,YAAjB,EAA+BL,IAA/B,EAAwC;AAClE;AACD,GAFD;;AAIA,MAAMM,YAAYrB,OAAOW,KAAzB;AACAX,SAAOW,KAAP,GAAe,UAASW,IAAT,EAAeC,IAAf,EAAqB;AAClCpB,UAAMmB,IAAN;AACAV,qBAAiB,qBAAjB;;AAEAS,cAAUG,IAAV,CAAe,IAAf,EAAqBD,IAArB;;AAEA,QAAME,WAAWb,cAAjB;AACAA,qBAAiB,qBAAjB;AACA,WAAOa,QAAP;AACD,GATD;;AAWA,SAAOzB,MAAP;AACD","file":"deps.js","sourcesContent":["import { List, Map } from 'immutable';\nimport { Parser } from 'hot-formula-parser';\nimport { CellRef } from 'sheety-model';\n\n/**\n * deps takes a collection of SheetyModel Tab objects and returns\n * a Map from CellRef c to a collection of CellRefs d, where each\n * CellRef c depends on the result of the CellRefs d.\n **/\nexport default function deps(tabs) {\n  const parser = getDependencyParser();\n\n  return tabs.reduce((deps, tab) => (\n    tab.get('rows').reduce((deps, row, rowIdx) => (\n      row.reduce((deps, cell, colIdx) => (\n        cell.get('formula')\n          ? deps.set(CellRef.of(tab, rowIdx, colIdx), parser.parse(tab, cell.get('formula')))\n          : deps\n      ), deps)\n    ), deps)\n  ), new Map());\n}\n\nfunction getDependencyParser() {\n  const parser = new Parser();\n  let dependentCells = new List();\n  let tab = null;\n  parser.on('callCellValue', (cellCoord, done) => {\n    dependentCells = dependentCells.push(\n      CellRef.of(tab, cellCoord.row.index, cellCoord.column.index)\n    );\n    done(0); // we don't care about the value\n  });\n  parser.on('callRangeValue', (startCellCoord, endCellCoord, done) => {\n    // TODO: implement this\n  });\n\n  const origParse = parser.parse;\n  parser.parse = function(_tab, expr) {\n    tab = _tab;\n    dependentCells = new List();\n\n    origParse.call(this, expr);\n\n    const depCells = dependentCells;\n    dependentCells = new List();\n    return depCells;\n  };\n\n  return parser;\n}\n"]}