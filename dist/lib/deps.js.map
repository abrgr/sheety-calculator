{"version":3,"sources":["../../src/lib/deps.js"],"names":["deps","tabs","parser","getDependencyParser","reduce","tab","get","row","rowIdx","cell","colIdx","set","of","parse","dependentCells","on","cellCoord","done","push","tabId","index","column","startCellCoord","endCellCoord","range","start","end","dependentRows","map","cellRef","_","concat","origParse","_tab","expr","call","depCells"],"mappings":";;;;;kBASwBA,I;;AATxB;;AACA;;AACA;;AAEA;;;;;AAKe,SAASA,IAAT,CAAcC,IAAd,EAAoB;AACjC,MAAMC,SAASC,qBAAf;;AAEA,SAAOF,KAAKG,MAAL,CAAY,UAACJ,IAAD,EAAOK,GAAP;AAAA,WACjBA,IAAIC,GAAJ,CAAQ,MAAR,EAAgBF,MAAhB,CAAuB,UAACJ,IAAD,EAAOO,GAAP,EAAYC,MAAZ;AAAA,aACrBD,IAAIH,MAAJ,CAAW,UAACJ,IAAD,EAAOS,IAAP,EAAaC,MAAb;AAAA,eACTD,KAAKH,GAAL,CAAS,SAAT,IACIN,KAAKW,GAAL,CAAS,qBAAQC,EAAR,CAAWP,GAAX,EAAgBG,MAAhB,EAAwBE,MAAxB,CAAT,EAA0CR,OAAOW,KAAP,CAAaR,IAAIC,GAAJ,CAAQ,IAAR,CAAb,EAA4BG,KAAKH,GAAL,CAAS,SAAT,CAA5B,CAA1C,CADJ,GAEIN,IAHK;AAAA,OAAX,EAIGA,IAJH,CADqB;AAAA,KAAvB,EAMGA,IANH,CADiB;AAAA,GAAZ,EAQJ,oBARI,CAAP;AASD;;AAED,SAASG,mBAAT,GAA+B;AAC7B,MAAMD,SAAS,8BAAf;AACA,MAAIY,iBAAiB,qBAArB;AACA,MAAIT,MAAM,IAAV;AACAH,SAAOa,EAAP,CAAU,eAAV,EAA2B,UAACC,SAAD,EAAYC,IAAZ,EAAqB;AAC9CH,qBAAiBA,eAAeI,IAAf,CACf,yBAAY;AACVC,aAAOH,UAAUX,GAAV,IAAiBA,GADd;AAEVG,cAAQQ,UAAUT,GAAV,CAAca,KAFZ;AAGVV,cAAQM,UAAUK,MAAV,CAAiBD;AAHf,KAAZ,CADe,CAAjB;AAOAH,SAAK,CAAL,EAR8C,CAQrC;AACV,GATD;AAUAf,SAAOa,EAAP,CAAU,gBAAV,EAA4B,UAACO,cAAD,EAAiBC,YAAjB,EAA+BN,IAA/B,EAAwC;AAClE,QAAMO,QAAQ,8BAAiB;AAC7BC,aAAO;AACLN,eAAOG,eAAejB,GAAf,IAAsBA,GADxB;AAELG,gBAAQc,eAAef,GAAf,CAAmBa,KAFtB;AAGLV,gBAAQY,eAAeD,MAAf,CAAsBD;AAHzB,OADsB;AAM7BM,WAAK;AACHP,eAAOG,eAAejB,GAAf,IAAsBA,GAD1B;AAEHG,gBAAQe,aAAahB,GAAb,CAAiBa,KAFtB;AAGHV,gBAAQa,aAAaF,MAAb,CAAoBD;AAHzB;AANwB,KAAjB,CAAd;AAYA,QAAMO,gBAAgBH,MAAMI,GAAN,CAAU;AAAA,aAC9BC,QAAQlB,GAAR,CAAY,OAAZ,EAAqBkB,QAAQvB,GAAR,CAAY,OAAZ,KAAwBD,GAA7C,CAD8B;AAAA,KAAV,CAAtB;;AAIAS,qBAAiBa,cAAcvB,MAAd,CAAqB,UAAC0B,CAAD,EAAIvB,GAAJ;AAAA,aACpCO,eAAeiB,MAAf,CAAsB,oBAASxB,GAAT,CAAtB,CADoC;AAAA,KAArB,EAEdO,cAFc,CAAjB;;AAIA,WAAO,CAAC,EAAD,CAAP;AACD,GAtBD;;AAwBA,MAAMkB,YAAY9B,OAAOW,KAAzB;AACAX,SAAOW,KAAP,GAAe,UAASoB,IAAT,EAAeC,IAAf,EAAqB;AAClC7B,UAAM4B,IAAN;AACAnB,qBAAiB,qBAAjB;;AAEAkB,cAAUG,IAAV,CAAe,IAAf,EAAqBD,IAArB;;AAEA,QAAME,WAAWtB,cAAjB;AACAA,qBAAiB,qBAAjB;AACA,WAAOsB,QAAP;AACD,GATD;;AAWA,SAAOlC,MAAP;AACD","file":"deps.js","sourcesContent":["import { List, Map } from 'immutable';\nimport { Parser } from 'hot-formula-parser';\nimport { CellRef, CellRefRange } from 'sheety-model';\n\n/**\n * deps takes a collection of SheetyModel Tab objects and returns\n * a Map from CellRef c to a collection of CellRefs d, where each\n * CellRef c depends on the result of the CellRefs d.\n **/\nexport default function deps(tabs) {\n  const parser = getDependencyParser();\n\n  return tabs.reduce((deps, tab) => (\n    tab.get('rows').reduce((deps, row, rowIdx) => (\n      row.reduce((deps, cell, colIdx) => (\n        cell.get('formula')\n          ? deps.set(CellRef.of(tab, rowIdx, colIdx), parser.parse(tab.get('id'), cell.get('formula')))\n          : deps\n      ), deps)\n    ), deps)\n  ), new Map());\n}\n\nfunction getDependencyParser() {\n  const parser = new Parser();\n  let dependentCells = new List();\n  let tab = null;\n  parser.on('callCellValue', (cellCoord, done) => {\n    dependentCells = dependentCells.push(\n      new CellRef({\n        tabId: cellCoord.tab || tab,\n        rowIdx: cellCoord.row.index,\n        colIdx: cellCoord.column.index\n      })\n    );\n    done(0); // we don't care about the value\n  });\n  parser.on('callRangeValue', (startCellCoord, endCellCoord, done) => {\n    const range = new CellRefRange({\n      start: {\n        tabId: startCellCoord.tab || tab,\n        rowIdx: startCellCoord.row.index,\n        colIdx: startCellCoord.column.index\n      },\n      end: {\n        tabId: startCellCoord.tab || tab,\n        rowIdx: endCellCoord.row.index,\n        colIdx: endCellCoord.column.index\n      }\n    });\n    const dependentRows = range.map(cellRef => (\n      cellRef.set('tabId', cellRef.get('tabId') || tab)\n    ));\n\n    dependentCells = dependentRows.reduce((_, row) => (\n      dependentCells.concat(new List(row))\n    ), dependentCells);\n\n    return [[]];\n  });\n\n  const origParse = parser.parse;\n  parser.parse = function(_tab, expr) {\n    tab = _tab;\n    dependentCells = new List();\n\n    origParse.call(this, expr);\n\n    const depCells = dependentCells;\n    dependentCells = new List();\n    return depCells;\n  };\n\n  return parser;\n}\n"]}